# ES-6新特性
## 定义变量
- var
    - 声明提前，变量重复声明不会报错
    - 全局作用域下声明的变量相当于window对象的属性
    - 仅在function内部声明的变量为私有变量
- function
    - 声明提前并定义（函数变量）
    - 全局作用域下声明的函数相当于window对象的属性
    - if(){}中定义的function提前声明，在为true时才会定义
- let
    - 不会变量提前，变量重复声明会报错
    - 定义的变量不会给window增加属性
    - 在块级作用域中声明的变量为私有变量
    - 在for(){}中`()`和`{}`使用let声明的变量均为私有变量
- const
    - 不会变量提前，变量重复声明会报错
    - 定义的变量不会给window增加属性
    - 声明的时一个常量，变量名应全部使用大写
    - 变量一旦声明必须赋值，且无法修改或重新赋值
## 块级作用域
- 由`{}`包裹形成的作用域，如：for(){},if(){},function(){}等
- 以`{`开头的语句会被认为是块级作用域而非对象，使用`({})`才识别为对象 
## 解构赋值
### 数组的解构赋值
**1.声明变量并赋值**
`let [a, b] = [1, 2]`
结果：`a = 1, b = 2`
**2.设置默认值**
`let [a, b = 3] = [1]`
结果：`a = 1, b = 3`
`let [a = 9, b] = [1]`
结果：`a = 1, b = undefined`
`let [a = 9, b = 1] = [undefined, null]`
结果：`a = 9, b = null`
*如果赋的值===undefined，则使用默认值*
**3.交换变量**
`let a = 3, b = 4;`
`[a, b] = [b, a];`
结果：`a = 4, b = 3`
**4.跳过某些值**
`let [a, b, , c] = [1, 2, 3, 4, 5]`
结果：`a = 1, b = 2, c = 4`
**5.剩余模式**
`let [a, ...b] = [1, 2, 3, 4]`
结果：`a = 1, b = [2, 3, 4]`
**类数组**
`let [a, b] = "123"`
结果：`a = "1", b = "2"`
*如果右边不是数组，但是是类数组（有length属性），则转换为数组，*
### 对象的解构赋值
**1.声明变量并赋值**
`let {a, b} = {a: 1, b: 2}`
结果：`a = 1, b = 2`
`let {b, a} = {a: 1, b: 2}`
结果：`a = 1, b = 2`
`let {c, a} = {a: 1, b: 2}`
结果：`a = 1, c = undefined`
*存在同名属性时才可以进行赋值*
**2.给新变量赋值**
`let {p: foo, q: bar} = {p: 42, q: true}`
结果：`foo = 42, bar = true`
**3.设置默认值**
`let {p, q = 12} = {p: 42}`
结果：`p = 12, q = 12`
`let {p = 12, q} = {p: 42}`
结果：`p = 42, q = undefined`
`let {p = 1, q = 1} = {p: undefined, q: null}`
结果：`p = undefined, q = null`
`let {p: foo, q: bar = 12} = {p: 42}`
结果：`foo = 42, bar = 12`
`let {p: foo = 12, q: bar} = {p: 42}`
结果：`foo = 42, bar = undefined`
`let {p: foo = 1, q: bar = 1} = {p: undefined, q: null}`
结果：`foo = 1, bar = null`
*如果赋的值===undefined，则使用默认值*
**4.剩余模式**
`let {p: foo, ...rest} = {p: 42, q: true}`
结果：`foo = 42, rest = {q: true}`
**非对象**
`let {__proto__: a} = 1`
结果：`a = 1`
`Object(1)` === `{__proto__: 1}`
*如果等号右边不是对象则转换成对象*
*结构对象时会查找原型链（属性不在对象自身时）*
### 函数参数中的解构赋值
`function get([a, b] = arr){}`
`function get([a = 4, b] = arr){}`
`function get([a, , b] = arr){}`
`function get([a,...rest] = arr){}`
**以上arr为函数传入的数组参数**
`function get([a, b] = [1, 2]){}`
`function get([a = 4, b] = [1, 2]){}`
`function get([a, , b] = [1, 2]){}`
`function get([a,...rest] = [1, 2]){}`
**此时函数传入参数将取代`=`右边的值**
`function get({a, b} = obj){}`
`function get({a, b = 3} = obj){}`
`function get({a, b: str} = obj){}`
`function get({a, b: str = "123"} = obj){}`
`function get({a, ...rest} = obj){}`
**obj为函数传入的对象参数**
`function get({a, b} = {a: 1, b: 2}){}`
`function get({a = 1, b = 2} = {}){}`
`function get({a, b = 3} = {a: 1, b: 2}){}`
`function get({a, b: str} = {a: 1, b: 2}){}`
`function get({a, b: str = "123"} = {a: 1, b: 2}){}`
`function get({a, ...rest} = {a: 1, b: 2}){}
**此时函数传入参数将取代`=`右边的值**

### 解构嵌套的数组和对象
`let key = "z";`
`let { [key]: foo } = { z: "bar" };`
结果：`foo = "bar"`
`const metadata = {`
  `title: 'Scratchpad',`
 ` translations: [`
    `{`
      `locale: 'de',`
      `localization_tags: [],`
      `last_edit: '2014-04-14T08:43:37',`
      `url: '/de/docs/Tools/Scratchpad',`
      `title: 'JavaScript-Umgebung'`
    `}`
  `],`
  `url: '/en-US/docs/Tools/Scratchpad'`
`};`

`let {`
  `title: englishTitle, // rename`
  `translations: [`
    `{`
       `title: localeTitle, // rename`
    `},`
  `],`
`} = metadata;`

`console.log(englishTitle); // "Scratchpad"`
`console.log(localeTitle);  // "JavaScript-Umgebung"`
[MDN-解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

## 字符串扩展
