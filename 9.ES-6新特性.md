# ES-6新特性
## 定义变量
- var
    - 声明提前，变量重复声明不会报错
    - 全局作用域下声明的变量相当于window对象的属性
    - 仅在function内部声明的变量为私有变量
- function
    - 声明提前并定义（函数变量）
    - 全局作用域下声明的函数相当于window对象的属性
    - if(){}中定义的function提前声明，在为true时才会定义
- let
    - 不会变量提前，变量重复声明会报错
    - 定义的变量不会给window增加属性
    - 在块级作用域中声明的变量为私有变量
    - 在for(){}中`()`和`{}`使用let声明的变量均为私有变量
- const
    - 不会变量提前，变量重复声明会报错
    - 定义的变量不会给window增加属性
    - 声明的时一个常量，变量名应全部使用大写
    - 变量一旦声明必须赋值，且无法修改或重新赋值
## 块级作用域
- 由`{}`包裹形成的作用域，如：for(){},if(){},function(){}等
- 以`{`开头的语句会被认为是块级作用域而非对象，使用`({})`才识别为对象 
## 解构赋值
### 数组的解构赋值
**1.声明变量并赋值**
```js
let [a, b] = [1, 2]
结果：a = 1, b = 2
```
**2.设置默认值**
```js
let [a, b = 3] = [1]
结果：a = 1, b = 3
let [a = 9, b] = [1]
结果：a = 1, b = undefined
let [a = 9, b = 1] = [undefined, null]
结果：a = 9, b = null
```
*如果赋的值===undefined，则使用默认值*
**3.交换变量**
```js
let a = 3, b = 4;
[a, b] = [b, a];
结果：a = 4, b = 3
```
**4.跳过某些值**
```js
let [a, b, , c] = [1, 2, 3, 4, 5]
结果：a = 1, b = 2, c = 4
```
**5.剩余模式**
```js
let [a, ...b] = [1, 2, 3, 4]
结果：a = 1, b = [2, 3, 4]
```
**类数组**
```js
let [a, b] = "123"
结果：a = "1", b = "2"
```
*如果右边不是数组，但是是类数组（有length属性），则转换为数组，*
### 对象的解构赋值
**1.声明变量并赋值**
```js
let {a, b} = {a: 1, b: 2}
结果：a = 1, b = 2
let {b, a} = {a: 1, b: 2}
结果：a = 1, b = 2
let {c, a} = {a: 1, b: 2}
结果：a = 1, c = undefined
```
*存在同名属性时才可以进行赋值*
**2.给新变量赋值**
```js
let {p: foo, q: bar} = {p: 42, q: true}
结果：foo = 42, bar = true
```
**3.设置默认值**
```js
let {p, q = 12} = {p: 42}
结果：p = 12, q = 12
let {p = 12, q} = {p: 42}
结果：p = 42, q = undefined
let {p = 1, q = 1} = {p: undefined, q: null}
结果：p = undefined, q = null
let {p: foo, q: bar = 12} = {p: 42}
结果：foo = 42, bar = 12
let {p: foo = 12, q: bar} = {p: 42}
结果：foo = 42, bar = undefined
let {p: foo = 1, q: bar = 1} = {p: undefined, q: null}
结果：foo = 1, bar = null
```
*如果赋的值===undefined，则使用默认值*
**4.剩余模式**
```js
let {p: foo, ...rest} = {p: 42, q: true}
结果：foo = 42, rest = {q: true}
```
**非对象**
```js
let {__proto__: a} = 1
结果：a = 1
Object(1) === {__proto__: 1}
```
*如果等号右边不是对象则转换成对象*
*结构对象时会查找原型链（属性不在对象自身时）*

### 函数参数中的解构赋值
```js
function get([a, b] = arr){}
function get([a = 4, b] = arr){}
function get([a, , b] = arr){}
function get([a,...rest] = arr){}
//arr为函数传入的数组参数
```
```js
function get([a, b] = [1, 2]){}
function get([a = 4, b] = [1, 2]){}
function get([a, , b] = [1, 2]){}
function get([a,...rest] = [1, 2]){}
//此时函数传入参数将取代`=`右边的值
```
```js
function get({a, b} = obj){}
function get({a, b = 3} = obj){}
function get({a, b: str} = obj){}
function get({a, b: str = "123"} = obj){}
function get({a, ...rest} = obj){}
//obj为函数传入的对象参数
```
```js
function get({a, b} = {a: 1, b: 2}){}
function get({a = 1, b = 2} = {}){}
function get({a, b = 3} = {a: 1, b: 2}){}
function get({a, b: str} = {a: 1, b: 2}){}
function get({a, b: str = "123"} = {a: 1, b: 2}){}
function get({a, ...rest} = {a: 1, b: 2}){}
//此时函数传入参数将取代=右边的值
```
### 解构嵌套的数组和对象
```js
let key = "z";
let { [key]: foo } = { z: "bar" };
结果：foo = "bar"
```
```js
const metadata = {
  title: 'Scratchpad',
  translations: [
    {
      locale: 'de',
      localization_tags: [],
      last_edit: '2014-04-14T08:43:37',
      url: '/de/docs/Tools/Scratchpad',
      title: 'JavaScript-Umgebung'
    }
  ],
  url: '/en-US/docs/Tools/Scratchpad'
};

let {
  title: englishTitle, // rename
  translations: [
    {
       title: localeTitle, // rename
    },
  ],
} = metadata;
console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"
```
[MDN-解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
## Class定义类
## Promise对象
## String扩展
### 模板字符串
> 使用反引号\`\`包裹的字符串，里面可以直接嵌套变量/表达式（使用${}包裹），中间空白正常保留

```js
let num = 123;
This is a String ${num} ${1 + 3}
结果为:This is a String 123 4
```
### 新增方法
includes，startsWith，endsWith，padStart，padEnd
[String方法参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)

## Array的扩展
### 扩展运算符
### 新增方法
## Object的扩展
## Function的扩展
