# 理解函数
## 函数定义
### 函数声明
在全局/块级作用域内以function开头的函数
//a和b均为函数声明
`function a(){ fucntion b() {}}`

### 函数表达式
其他表达式中的函数（匿名/命名函数）为函数表达式，
//赋值给变量/对象属性的函数表达式
`let a = function(){};`
//函数调用中的的函数表达式
`+function(){}()`
`(function(){}());`
`(function(){})();`
//作为操作数的函数表达式
`!function(){}`
//函数参数中的函数表达式
`function name( fucntion second(){} ){}`
//函数返回值中的函数表达式
`function name(){ return function(){} }`

### new构建函数
以`new Function()`的方式动态构建的一个函数
`let a = new Function('return 123');`
`new Function('a', 'b', 'return a + b')`

### ES-6新增方式
- 箭头函数
  即Lambda函数，以`() => {}`的形式定义的函数
  箭头函数没有自己的this/arguments/super/new.target
  `let a = x => x + 1;`
  `let b = (a, b) => { return a + b };`
  /箭头函数作为回调函数
  `[1, 2, 3].reduce((a, b) => a + b)`
- 生成器函数
  创建不同于普通函数的函数
  `fucntion * gen(){yiels 1;}`

## 属性&参数
### this
>this是函数内部的一个隐式参数，指向函数的上下文环境/执行环境
>箭头函数的this会被绑定到其上一层作用域的this上，且call/apply/bind方法无效

**this指向**
- 函数作为函数调用时，this指向全局上下文/window对象
- 函数作为对象的方法时，this指向该调用该方法的对象
- 函数作为构造函数时，this指向构造函数创建的实例对象
- 函数应用call/apply/bind方法时，将this绑定到目标对象

### arguments
> arguments是所有函数（非箭头函数）中可用的局部变量/隐式参数
> arguments是一个类数组，存储着函数调用时实际传入的参数
> `arguments.length`，`arguments[i]`

**arguments转换为数组的方法**
- `let args = [...arguments]`
- `let args = Array.from(arguments)`
- `let args = [].slice().call(arguments)`
- `let args = Array.prototype.slice().call(arguments)`

### prototype
>prototype（原型）是所有函数特有的属性，指向原型对象的引用
>在构造函数中，prototype属性指向构造函数本身的原型对象

## call&apply&bind
>在某个特定的作用域中调用函数，将调用函数的this绑定到某个变量对象上
>call和apply会绑定this并调用函数，bind会绑定this并返回一个函数

- call：`func.call(thisArg, arg1, arg2, ...)`
- apply：`func.apply(thisArg, [argsArray])`
- bind：`func.bind(thisArg[, arg1[, arg2[, ...]]])`
- 实例：
	`window.color = "red";`
	`let obj = {color: "green"};`
	`let sayClor = function(){ reurn this.color};`
	`sayColor();    => red`
	`sayColor(this);    => red`
	`sayColor.call(window);    => red`
	`sayColor.call(o);    => green`

## getter&setter
>用于将对象的属性绑定到要调用的函数上，get/set用于查询/设置属性值，可使用delete删除

- 对象的属性中get/set的使用
	语法：
	`{get prop[exp]() { ... } }`
	`{set prop[exp](val) { ... } }`
	实例：
	`let obj = {`
		`nums: [1, 2, 3],`
		`get sum(){return nums.reduce((a, b) => a + b)},`
		`set mul(val){nums = nums.map(x => val * x)}`
	`}`
	`obj.sum;`
	`obj.mul(2);`
	`delete obj.sum;`
- Object.defineProperty()
	`let o = {a: 12};`
	`Object.defineProperty(o, "b", {`
        `get() { return this.a + 1; },`
        `set(newValue) { b = newValue; },`
        `enumerable : true,`
        `configurable : true`
	`});`
	[Object.defineProperty()参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

## 闭包&作用域
### 闭包
>闭包是有权访问另一个函数作用域中变量的函数，即可以访问另一个函数的作用域；闭包嵌套在另一个函数内部，或作为参数传入函数，闭包始终保存创建时所在作用域内的变量，消耗内存成本。

**闭包的使用**
1.封装私有变量
	将外部函数定义的私有变量保存在闭包中，并通过闭包内部方法访问私有变量
2.回调函数
	指在需要的时候进行异步调用的函数，作为函数参数传入
### 作用域
>在函数内定义的变量不能在函数外的任何地方访问，变量仅仅在该函内部有定义，即私有变量。
>函数的作用域指该函数的全部变量可以在整个函数范围内使用（包括嵌套的作用域中也可使用）

## 递归&柯里化
### 函数递归
递归：一个函数可以指向并调用自身，类似一个循环，递归未完成时，计算结果会被暂时挂起。
**示例**
`function add (n){`
	`if(n <= 1) return 1;`
	`return n + add(n-1);`
`}`
注意：递归需要存在一个终止条件，否则会无限递归

### 函数柯里化
currying：一种高阶函数的转换，`add(a, b)` => `add(a)(b)`
**示例**
`function add (a){`
	`return fnction(b){`
		`return a + b;`
	`}`
`}`
`add(1)(2)`

## 创建构造函数
**构造函数实例**
//构造函数以大写字母开头，以便区分于一般函数
`function Person(name){`
	//构造函数不必显示创建对象，而是使用this
	//将属性和方法赋给了this对象
	`this.name = name;`
	`this.say = function() {`
		`console.log("Hello!");`
	`};`
`}`
//必须使用new关键字创建实例对象
`let person1 = new Person("Tom");`
**实例创建过程**

- 创建一个新对象，this指向新对象
- 将构造函数的作用域赋给新对象
- 执行构造函数中的代码
- 返回这个新对象