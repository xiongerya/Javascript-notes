# 理解函数
## 函数定义
### 函数声明
在全局/块级作用域内以function开头的函数
//a和b均为函数声明
`function a(){ fucntion b() {}}`

### 函数表达式
其他表达式中的函数（匿名/命名函数）为函数表达式，
//赋值给变量/对象属性的函数表达式
`let a = function(){};`
//函数调用中的的函数表达式
`+function(){}()`
`(function(){}());`
`(function(){})();`
//作为操作数的函数表达式
`!function(){}`
//函数参数中的函数表达式
`function name( fucntion second(){} ){}`
//函数返回值中的函数表达式
`function name(){ return function(){} }`

### new构建函数
以`new Function()`的方式动态构建的一个函数
`let a = new Function('return 123');`
`new Function('a', 'b', 'return a + b')`

### ES-6新增方式
- 箭头函数
  即Lambda函数，以`() => {}`的形式定义的函数
  箭头函数没有自己的this/arguments/super/new.target
  `let a = x => x + 1;`
  `let b = (a, b) => { return a + b };`
  /箭头函数作为回调函数
  `[1, 2, 3].reduce((a, b) => a + b)`
- 生成器函数
  创建不同于普通函数的函数
  `fucntion * gen(){yiels 1;}`

## 属性&参数
### this
>this是函数内部的一个隐式参数，指向函数的上下文环境/执行环境
>箭头函数的this会被绑定到其上一层作用域的this上，且call/apply/bind方法无效

**this指向**
- 函数作为函数调用时，this指向全局上下文/window对象
- 函数作为对象的方法时，this指向该调用该方法的对象
- 函数作为构造函数时，this指向构造函数创建的实例对象
- 函数应用call/apply/bind方法时，将this绑定到目标对象

### arguments
> arguments是所有函数（非箭头函数）中可用的局部变量/隐式参数，调用函数时实际传入的参数
> arguments是一个类数组，`arguments.length`，`arguments[i]`
> 其他参数：parameter（形参）/剩余参数/默认参数

**arguments转换为数组的方法**
- `let args = [...arguments]`
- `let args = Array.from(arguments)`
- `let args = [].slice().call(arguments)`
- `let args = Array.prototype.slice().call(arguments)`

### prototype
>prototype（原型）是所有函数特有的属性，指向一个原型对象
>在构造函数中，prototype属性指向构造函数本身的原型对象

## 闭包&作用域
### 闭包
>闭包是有权访问另一个函数作用域中变量的函数，即可以访问另一个函数的作用域；闭包嵌套在另一个函数内部，或作为参数传入函数，闭包始终保存创建时所在作用域内的变量，消耗内存成本。

**闭包的使用**
1.封装私有变量
	将外部函数中声明的私有变量保存在闭包中，并通过闭包内部方法访问私有变量
2.回调函数
	指在需要的时候进行异步调用的函数，作为函数参数传入
### 作用域
>在函数内定义的变量不能在函数外的任何地方访问，变量仅仅在该函内部有定义，即私有变量。
>函数的作用域指该函数的全部变量可以在整个函数范围内使用（包括嵌套的作用域中也可使用）

## call&apply&bind
## getter&setter
## 递归&Currying
一个函数可以指向并调用自身
**实现递归的方式**
- 函数名调用
- 指向函数的变量
- arguments.callee

## 作为构造函数
使用new创建构造函数实例的过程：
1.创建一个新的空对象
2.将该对象作为this参数传递给构造函数，从而成为构造函数的函数上下文
3.新创建的对象作为new运算符的返回值